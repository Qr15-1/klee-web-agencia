---
import { Icon } from 'astro-icon/components';
import ImageCarousel from './ImageCarousel.astro';

const { t } = Astro.props;
---
<div class="container mx-auto px-6 mt-16">
    <section class="rounded-3xl bg-gradient-to-br from-red-500/20 via-blue-900/60 to-blue-500/20 px-6 py-16 md:py-24 relative overflow-hidden">
        
        <div class="absolute inset-0 bg-cover bg-center opacity-20" style="background-image: url('/hero-background.jpg');"></div>

        <div class="relative z-10 grid grid-cols-1 md:grid-cols-2 gap-12 md:gap-16 items-center">
            
            <div class="text-white">
                <div class="bg-white/5 backdrop-blur-sm border border-white/10 rounded-full p-2 flex items-center mb-10">
                    {/* 1. Añadimos un id único al input y dejamos el 'value' vacío inicialmente */}
                    <input 
                        id="socials-search-input" 
                        type="text" 
                        readonly 
                        value="" 
                        class="bg-transparent text-white placeholder-gray-300 w-full ml-4 focus:outline-none font-sans text-sm"
                        data-text={t('socialsSection.searchPlaceholder')}
                    >
                    <button class="bg-white/5 rounded-full p-2.5 hover:bg-white/20 transition-colors">
                        <Icon name="mdi:magnify" class="w-6 h-6 text-gray-300" />
                    </button>
                </div>
                <h2 class="font-display text-4xl md:text-6xl tracking-wide leading-tight mb-8">
                    {t('socialsSection.title1')} <br>
                    <span class="text-klee-yellow">{t('socialsSection.title2')}</span>
                </h2>
                <div class="font-sans text-gray-300 space-y-4 leading-relaxed">
                    <p>{t('socialsSection.p1')}</p>
                    <p>{t('socialsSection.p2')}</p>
                </div>
            </div>

            <!-- Columna derecha (sin cambios) -->
            <div>
                <div class="md:hidden">
                    <ImageCarousel />
                </div>
                <div class="hidden md:block relative min-h-[450px]">
                    <div class="p-1.5 bg-white rounded-2xl shadow-lg w-6/12 absolute top-1/2 -translate-y-1/2 left-0 z-10 -rotate-3">
                        <img src="/imagenes/nr3.jpg" alt="Plato del día" class="rounded-xl w-full h-auto object-cover">
                    </div>
                    <div class="p-1.5 bg-white rounded-2xl shadow-lg w-6/12 absolute top-0 left-1/4 z-20 rotate-2">
                        <img src="/imagenes/nr2.jpg" alt="Chica comiendo" class="rounded-xl w-full h-auto object-cover">
                    </div>
                    <div class="p-1.5 bg-white rounded-2xl shadow-lg w-6/12 absolute top-1/3 right-0 z-10 rotate-3">
                        <img src="/imagenes/nr1.jpg" alt="Proyecto inmobiliario" class="rounded-xl w-full h-auto object-cover">
                    </div>
                </div>
            </div>
        </div>
    </section>
</div>

<!-- 2. AÑADIMOS EL SCRIPT PARA LA ANIMACIÓN -->
<script>
    import Typewriter from 'typewriter-effect/dist/core';

    // Seleccionamos el input por su nuevo ID
    const searchInput = document.getElementById('socials-search-input');
    
    // Obtenemos el texto a escribir desde el atributo data-text
    const textToWrite = searchInput.dataset.text;

    // Creamos una instancia de Typewriter pero no la iniciamos todavía
    const typewriter = new Typewriter(searchInput, {
        loop: false,
        delay: 60,
        // Usamos el 'value' del input en lugar del contenido del elemento
        onCreateTextNode: (character) => {
            searchInput.value += character;
            return null; 
        },
        // Al borrar, reducimos el 'value' del input
        onRemoveNode: () => {
            if (searchInput.value.length > 0) {
                searchInput.value = searchInput.value.slice(0, -1);
            }
        },
    });

    // Creamos un 'Observer' que vigilará cuándo el input entra en la pantalla
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            // Si el input es visible y la animación no ha comenzado...
            if (entry.isIntersecting) {
                // Iniciamos la animación
                typewriter
                    .typeString(textToWrite)
                    .start();
                
                // Dejamos de observar el elemento para que la animación no se repita
                observer.unobserve(searchInput);
            }
        });
    }, {
        // threshold: 0.1 significa que la animación empieza cuando el 10% del elemento es visible
        threshold: 0.1
    });

    // Le decimos al observer que empiece a vigilar nuestro input
    observer.observe(searchInput);
</script>